/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package com.microsoft.bot.connector.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.bot.connector.ErrorResponseException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Conversations.
 */
public class ConversationsInner {
    /** The Retrofit service to perform REST calls. */
    private ConversationsService service;
    /** The service client containing this operation class. */
    private ConnectorClientImpl client;

    /**
     * Initializes an instance of ConversationsInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public ConversationsInner(Retrofit retrofit, ConnectorClientImpl client) {
        this.service = retrofit.create(ConversationsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Conversations to be
     * used by Retrofit to perform actually REST calls.
     */
    interface ConversationsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bot.connector.Conversations createConversation" })
        @POST("v3/conversations")
        Observable<Response<ResponseBody>> createConversation(@Body ConversationParametersInner parameters, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bot.connector.Conversations sendToConversation" })
        @POST("v3/conversations/{conversationId}/activities")
        Observable<Response<ResponseBody>> sendToConversation(@Path("conversationId") String conversationId, @Body ActivityInner activity, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bot.connector.Conversations updateActivity" })
        @PUT("v3/conversations/{conversationId}/activities/{activityId}")
        Observable<Response<ResponseBody>> updateActivity(@Path("conversationId") String conversationId, @Path("activityId") String activityId, @Body ActivityInner activity, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bot.connector.Conversations replyToActivity" })
        @POST("v3/conversations/{conversationId}/activities/{activityId}")
        Observable<Response<ResponseBody>> replyToActivity(@Path("conversationId") String conversationId, @Path("activityId") String activityId, @Body ActivityInner activity, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bot.connector.Conversations deleteActivity" })
        @HTTP(path = "v3/conversations/{conversationId}/activities/{activityId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteActivity(@Path("conversationId") String conversationId, @Path("activityId") String activityId, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bot.connector.Conversations getConversationMembers" })
        @GET("v3/conversations/{conversationId}/members")
        Observable<Response<ResponseBody>> getConversationMembers(@Path("conversationId") String conversationId, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bot.connector.Conversations getActivityMembers" })
        @GET("v3/conversations/{conversationId}/activities/{activityId}/members")
        Observable<Response<ResponseBody>> getActivityMembers(@Path("conversationId") String conversationId, @Path("activityId") String activityId, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bot.connector.Conversations uploadAttachment" })
        @POST("v3/conversations/{conversationId}/attachments")
        Observable<Response<ResponseBody>> uploadAttachment(@Path("conversationId") String conversationId, @Body AttachmentDataInner attachmentUpload, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * CreateConversation.
     * Create a new Conversation.
     POST to this method with a
     * Bot being the bot creating the conversation
     * IsGroup set to true if this is not a direct message (default is false)
     * Members array contining the members you want to have be in the conversation.
     The return value is a ResourceResponse which contains a conversation id which is suitable for use
     in the message payload and REST API uris.
     Most channels only support the semantics of bots initiating a direct message conversation.  An example of how to do that would be:
     ```
     var resource = await connector.conversations.CreateConversation(new ConversationParameters(){ Bot = bot, members = new ChannelAccount[] { new ChannelAccount("user1") } );
     await connect.Conversations.SendToConversationAsync(resource.Id, new Activity() ... ) ;
     ```.
     *
     * @param parameters Parameters to create the conversation from
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ConversationResourceResponseInner object if successful.
     */
    public ConversationResourceResponseInner createConversation(ConversationParametersInner parameters) {
        return createConversationWithServiceResponseAsync(parameters).toBlocking().single().body();
    }

    /**
     * CreateConversation.
     * Create a new Conversation.
     POST to this method with a
     * Bot being the bot creating the conversation
     * IsGroup set to true if this is not a direct message (default is false)
     * Members array contining the members you want to have be in the conversation.
     The return value is a ResourceResponse which contains a conversation id which is suitable for use
     in the message payload and REST API uris.
     Most channels only support the semantics of bots initiating a direct message conversation.  An example of how to do that would be:
     ```
     var resource = await connector.conversations.CreateConversation(new ConversationParameters(){ Bot = bot, members = new ChannelAccount[] { new ChannelAccount("user1") } );
     await connect.Conversations.SendToConversationAsync(resource.Id, new Activity() ... ) ;
     ```.
     *
     * @param parameters Parameters to create the conversation from
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ConversationResourceResponseInner> createConversationAsync(ConversationParametersInner parameters, final ServiceCallback<ConversationResourceResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(createConversationWithServiceResponseAsync(parameters), serviceCallback);
    }

    /**
     * CreateConversation.
     * Create a new Conversation.
     POST to this method with a
     * Bot being the bot creating the conversation
     * IsGroup set to true if this is not a direct message (default is false)
     * Members array contining the members you want to have be in the conversation.
     The return value is a ResourceResponse which contains a conversation id which is suitable for use
     in the message payload and REST API uris.
     Most channels only support the semantics of bots initiating a direct message conversation.  An example of how to do that would be:
     ```
     var resource = await connector.conversations.CreateConversation(new ConversationParameters(){ Bot = bot, members = new ChannelAccount[] { new ChannelAccount("user1") } );
     await connect.Conversations.SendToConversationAsync(resource.Id, new Activity() ... ) ;
     ```.
     *
     * @param parameters Parameters to create the conversation from
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ConversationResourceResponseInner object
     */
    public Observable<ConversationResourceResponseInner> createConversationAsync(ConversationParametersInner parameters) {
        return createConversationWithServiceResponseAsync(parameters).map(new Func1<ServiceResponse<ConversationResourceResponseInner>, ConversationResourceResponseInner>() {
            @Override
            public ConversationResourceResponseInner call(ServiceResponse<ConversationResourceResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * CreateConversation.
     * Create a new Conversation.
     POST to this method with a
     * Bot being the bot creating the conversation
     * IsGroup set to true if this is not a direct message (default is false)
     * Members array contining the members you want to have be in the conversation.
     The return value is a ResourceResponse which contains a conversation id which is suitable for use
     in the message payload and REST API uris.
     Most channels only support the semantics of bots initiating a direct message conversation.  An example of how to do that would be:
     ```
     var resource = await connector.conversations.CreateConversation(new ConversationParameters(){ Bot = bot, members = new ChannelAccount[] { new ChannelAccount("user1") } );
     await connect.Conversations.SendToConversationAsync(resource.Id, new Activity() ... ) ;
     ```.
     *
     * @param parameters Parameters to create the conversation from
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ConversationResourceResponseInner object
     */
    public Observable<ServiceResponse<ConversationResourceResponseInner>> createConversationWithServiceResponseAsync(ConversationParametersInner parameters) {
        if (parameters == null) {
            throw new IllegalArgumentException("Parameter parameters is required and cannot be null.");
        }
        Validator.validate(parameters);
        return service.createConversation(parameters, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ConversationResourceResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<ConversationResourceResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ConversationResourceResponseInner> clientResponse = createConversationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ConversationResourceResponseInner> createConversationDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ConversationResourceResponseInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ConversationResourceResponseInner>() { }.getType())
                .register(201, new TypeToken<ConversationResourceResponseInner>() { }.getType())
                .register(202, new TypeToken<ConversationResourceResponseInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * SendToConversation.
     * This method allows you to send an activity to the end of a conversation.
     This is slightly different from ReplyToActivity().
     * SendToConverstion(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.
     * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.
     Use ReplyToActivity when replying to a specific activity in the conversation.
     Use SendToConversation in all other cases.
     *
     * @param conversationId Conversation ID
     * @param activity Activity to send
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ResourceResponseInner object if successful.
     */
    public ResourceResponseInner sendToConversation(String conversationId, ActivityInner activity) {
        return sendToConversationWithServiceResponseAsync(conversationId, activity).toBlocking().single().body();
    }

    /**
     * SendToConversation.
     * This method allows you to send an activity to the end of a conversation.
     This is slightly different from ReplyToActivity().
     * SendToConverstion(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.
     * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.
     Use ReplyToActivity when replying to a specific activity in the conversation.
     Use SendToConversation in all other cases.
     *
     * @param conversationId Conversation ID
     * @param activity Activity to send
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ResourceResponseInner> sendToConversationAsync(String conversationId, ActivityInner activity, final ServiceCallback<ResourceResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(sendToConversationWithServiceResponseAsync(conversationId, activity), serviceCallback);
    }

    /**
     * SendToConversation.
     * This method allows you to send an activity to the end of a conversation.
     This is slightly different from ReplyToActivity().
     * SendToConverstion(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.
     * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.
     Use ReplyToActivity when replying to a specific activity in the conversation.
     Use SendToConversation in all other cases.
     *
     * @param conversationId Conversation ID
     * @param activity Activity to send
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResourceResponseInner object
     */
    public Observable<ResourceResponseInner> sendToConversationAsync(String conversationId, ActivityInner activity) {
        return sendToConversationWithServiceResponseAsync(conversationId, activity).map(new Func1<ServiceResponse<ResourceResponseInner>, ResourceResponseInner>() {
            @Override
            public ResourceResponseInner call(ServiceResponse<ResourceResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * SendToConversation.
     * This method allows you to send an activity to the end of a conversation.
     This is slightly different from ReplyToActivity().
     * SendToConverstion(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.
     * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.
     Use ReplyToActivity when replying to a specific activity in the conversation.
     Use SendToConversation in all other cases.
     *
     * @param conversationId Conversation ID
     * @param activity Activity to send
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResourceResponseInner object
     */
    public Observable<ServiceResponse<ResourceResponseInner>> sendToConversationWithServiceResponseAsync(String conversationId, ActivityInner activity) {
        if (conversationId == null) {
            throw new IllegalArgumentException("Parameter conversationId is required and cannot be null.");
        }
        if (activity == null) {
            throw new IllegalArgumentException("Parameter activity is required and cannot be null.");
        }
        Validator.validate(activity);
        return service.sendToConversation(conversationId, activity, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ResourceResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<ResourceResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ResourceResponseInner> clientResponse = sendToConversationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ResourceResponseInner> sendToConversationDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ResourceResponseInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ResourceResponseInner>() { }.getType())
                .register(201, new TypeToken<ResourceResponseInner>() { }.getType())
                .register(202, new TypeToken<ResourceResponseInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * UpdateActivity.
     * Edit an existing activity.
     Some channels allow you to edit an existing activity to reflect the new state of a bot conversation.
     For example, you can remove buttons after someone has clicked "Approve" button.
     *
     * @param conversationId Conversation ID
     * @param activityId activityId to update
     * @param activity replacement Activity
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ResourceResponseInner object if successful.
     */
    public ResourceResponseInner updateActivity(String conversationId, String activityId, ActivityInner activity) {
        return updateActivityWithServiceResponseAsync(conversationId, activityId, activity).toBlocking().single().body();
    }

    /**
     * UpdateActivity.
     * Edit an existing activity.
     Some channels allow you to edit an existing activity to reflect the new state of a bot conversation.
     For example, you can remove buttons after someone has clicked "Approve" button.
     *
     * @param conversationId Conversation ID
     * @param activityId activityId to update
     * @param activity replacement Activity
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ResourceResponseInner> updateActivityAsync(String conversationId, String activityId, ActivityInner activity, final ServiceCallback<ResourceResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateActivityWithServiceResponseAsync(conversationId, activityId, activity), serviceCallback);
    }

    /**
     * UpdateActivity.
     * Edit an existing activity.
     Some channels allow you to edit an existing activity to reflect the new state of a bot conversation.
     For example, you can remove buttons after someone has clicked "Approve" button.
     *
     * @param conversationId Conversation ID
     * @param activityId activityId to update
     * @param activity replacement Activity
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResourceResponseInner object
     */
    public Observable<ResourceResponseInner> updateActivityAsync(String conversationId, String activityId, ActivityInner activity) {
        return updateActivityWithServiceResponseAsync(conversationId, activityId, activity).map(new Func1<ServiceResponse<ResourceResponseInner>, ResourceResponseInner>() {
            @Override
            public ResourceResponseInner call(ServiceResponse<ResourceResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * UpdateActivity.
     * Edit an existing activity.
     Some channels allow you to edit an existing activity to reflect the new state of a bot conversation.
     For example, you can remove buttons after someone has clicked "Approve" button.
     *
     * @param conversationId Conversation ID
     * @param activityId activityId to update
     * @param activity replacement Activity
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResourceResponseInner object
     */
    public Observable<ServiceResponse<ResourceResponseInner>> updateActivityWithServiceResponseAsync(String conversationId, String activityId, ActivityInner activity) {
        if (conversationId == null) {
            throw new IllegalArgumentException("Parameter conversationId is required and cannot be null.");
        }
        if (activityId == null) {
            throw new IllegalArgumentException("Parameter activityId is required and cannot be null.");
        }
        if (activity == null) {
            throw new IllegalArgumentException("Parameter activity is required and cannot be null.");
        }
        Validator.validate(activity);
        return service.updateActivity(conversationId, activityId, activity, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ResourceResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<ResourceResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ResourceResponseInner> clientResponse = updateActivityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ResourceResponseInner> updateActivityDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ResourceResponseInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ResourceResponseInner>() { }.getType())
                .register(201, new TypeToken<ResourceResponseInner>() { }.getType())
                .register(202, new TypeToken<ResourceResponseInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * ReplyToActivity.
     * This method allows you to reply to an activity.
     This is slightly different from SendToConversation().
     * SendToConverstion(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.
     * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.
     Use ReplyToActivity when replying to a specific activity in the conversation.
     Use SendToConversation in all other cases.
     *
     * @param conversationId Conversation ID
     * @param activityId activityId the reply is to (OPTIONAL)
     * @param activity Activity to send
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ResourceResponseInner object if successful.
     */
    public ResourceResponseInner replyToActivity(String conversationId, String activityId, ActivityInner activity) {
        return replyToActivityWithServiceResponseAsync(conversationId, activityId, activity).toBlocking().single().body();
    }

    /**
     * ReplyToActivity.
     * This method allows you to reply to an activity.
     This is slightly different from SendToConversation().
     * SendToConverstion(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.
     * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.
     Use ReplyToActivity when replying to a specific activity in the conversation.
     Use SendToConversation in all other cases.
     *
     * @param conversationId Conversation ID
     * @param activityId activityId the reply is to (OPTIONAL)
     * @param activity Activity to send
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ResourceResponseInner> replyToActivityAsync(String conversationId, String activityId, ActivityInner activity, final ServiceCallback<ResourceResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(replyToActivityWithServiceResponseAsync(conversationId, activityId, activity), serviceCallback);
    }

    /**
     * ReplyToActivity.
     * This method allows you to reply to an activity.
     This is slightly different from SendToConversation().
     * SendToConverstion(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.
     * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.
     Use ReplyToActivity when replying to a specific activity in the conversation.
     Use SendToConversation in all other cases.
     *
     * @param conversationId Conversation ID
     * @param activityId activityId the reply is to (OPTIONAL)
     * @param activity Activity to send
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResourceResponseInner object
     */
    public Observable<ResourceResponseInner> replyToActivityAsync(String conversationId, String activityId, ActivityInner activity) {
        return replyToActivityWithServiceResponseAsync(conversationId, activityId, activity).map(new Func1<ServiceResponse<ResourceResponseInner>, ResourceResponseInner>() {
            @Override
            public ResourceResponseInner call(ServiceResponse<ResourceResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * ReplyToActivity.
     * This method allows you to reply to an activity.
     This is slightly different from SendToConversation().
     * SendToConverstion(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.
     * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.
     Use ReplyToActivity when replying to a specific activity in the conversation.
     Use SendToConversation in all other cases.
     *
     * @param conversationId Conversation ID
     * @param activityId activityId the reply is to (OPTIONAL)
     * @param activity Activity to send
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResourceResponseInner object
     */
    public Observable<ServiceResponse<ResourceResponseInner>> replyToActivityWithServiceResponseAsync(String conversationId, String activityId, ActivityInner activity) {
        if (conversationId == null) {
            throw new IllegalArgumentException("Parameter conversationId is required and cannot be null.");
        }
        if (activityId == null) {
            throw new IllegalArgumentException("Parameter activityId is required and cannot be null.");
        }
        if (activity == null) {
            throw new IllegalArgumentException("Parameter activity is required and cannot be null.");
        }
        Validator.validate(activity);
        return service.replyToActivity(conversationId, activityId, activity, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ResourceResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<ResourceResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ResourceResponseInner> clientResponse = replyToActivityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ResourceResponseInner> replyToActivityDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ResourceResponseInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ResourceResponseInner>() { }.getType())
                .register(201, new TypeToken<ResourceResponseInner>() { }.getType())
                .register(202, new TypeToken<ResourceResponseInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * DeleteActivity.
     * Delete an existing activity.
     Some channels allow you to delete an existing activity, and if successful this method will remove the specified activity.
     *
     * @param conversationId Conversation ID
     * @param activityId activityId to delete
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteActivity(String conversationId, String activityId) {
        deleteActivityWithServiceResponseAsync(conversationId, activityId).toBlocking().single().body();
    }

    /**
     * DeleteActivity.
     * Delete an existing activity.
     Some channels allow you to delete an existing activity, and if successful this method will remove the specified activity.
     *
     * @param conversationId Conversation ID
     * @param activityId activityId to delete
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteActivityAsync(String conversationId, String activityId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteActivityWithServiceResponseAsync(conversationId, activityId), serviceCallback);
    }

    /**
     * DeleteActivity.
     * Delete an existing activity.
     Some channels allow you to delete an existing activity, and if successful this method will remove the specified activity.
     *
     * @param conversationId Conversation ID
     * @param activityId activityId to delete
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteActivityAsync(String conversationId, String activityId) {
        return deleteActivityWithServiceResponseAsync(conversationId, activityId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * DeleteActivity.
     * Delete an existing activity.
     Some channels allow you to delete an existing activity, and if successful this method will remove the specified activity.
     *
     * @param conversationId Conversation ID
     * @param activityId activityId to delete
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteActivityWithServiceResponseAsync(String conversationId, String activityId) {
        if (conversationId == null) {
            throw new IllegalArgumentException("Parameter conversationId is required and cannot be null.");
        }
        if (activityId == null) {
            throw new IllegalArgumentException("Parameter activityId is required and cannot be null.");
        }
        return service.deleteActivity(conversationId, activityId, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteActivityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteActivityDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * GetConversationMembers.
     * Enumerate the members of a converstion.
     This REST API takes a ConversationId and returns an array of ChannelAccount objects representing the members of the conversation.
     *
     * @param conversationId Conversation ID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ChannelAccountInner&gt; object if successful.
     */
    public List<ChannelAccountInner> getConversationMembers(String conversationId) {
        return getConversationMembersWithServiceResponseAsync(conversationId).toBlocking().single().body();
    }

    /**
     * GetConversationMembers.
     * Enumerate the members of a converstion.
     This REST API takes a ConversationId and returns an array of ChannelAccount objects representing the members of the conversation.
     *
     * @param conversationId Conversation ID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ChannelAccountInner>> getConversationMembersAsync(String conversationId, final ServiceCallback<List<ChannelAccountInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getConversationMembersWithServiceResponseAsync(conversationId), serviceCallback);
    }

    /**
     * GetConversationMembers.
     * Enumerate the members of a converstion.
     This REST API takes a ConversationId and returns an array of ChannelAccount objects representing the members of the conversation.
     *
     * @param conversationId Conversation ID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ChannelAccountInner&gt; object
     */
    public Observable<List<ChannelAccountInner>> getConversationMembersAsync(String conversationId) {
        return getConversationMembersWithServiceResponseAsync(conversationId).map(new Func1<ServiceResponse<List<ChannelAccountInner>>, List<ChannelAccountInner>>() {
            @Override
            public List<ChannelAccountInner> call(ServiceResponse<List<ChannelAccountInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * GetConversationMembers.
     * Enumerate the members of a converstion.
     This REST API takes a ConversationId and returns an array of ChannelAccount objects representing the members of the conversation.
     *
     * @param conversationId Conversation ID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ChannelAccountInner&gt; object
     */
    public Observable<ServiceResponse<List<ChannelAccountInner>>> getConversationMembersWithServiceResponseAsync(String conversationId) {
        if (conversationId == null) {
            throw new IllegalArgumentException("Parameter conversationId is required and cannot be null.");
        }
        return service.getConversationMembers(conversationId, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ChannelAccountInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ChannelAccountInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ChannelAccountInner>> clientResponse = getConversationMembersDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ChannelAccountInner>> getConversationMembersDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<ChannelAccountInner>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<ChannelAccountInner>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * GetActivityMembers.
     * Enumerate the members of an activity.
     This REST API takes a ConversationId and a ActivityId, returning an array of ChannelAccount objects representing the members of the particular activity in the conversation.
     *
     * @param conversationId Conversation ID
     * @param activityId Activity ID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ChannelAccountInner&gt; object if successful.
     */
    public List<ChannelAccountInner> getActivityMembers(String conversationId, String activityId) {
        return getActivityMembersWithServiceResponseAsync(conversationId, activityId).toBlocking().single().body();
    }

    /**
     * GetActivityMembers.
     * Enumerate the members of an activity.
     This REST API takes a ConversationId and a ActivityId, returning an array of ChannelAccount objects representing the members of the particular activity in the conversation.
     *
     * @param conversationId Conversation ID
     * @param activityId Activity ID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ChannelAccountInner>> getActivityMembersAsync(String conversationId, String activityId, final ServiceCallback<List<ChannelAccountInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getActivityMembersWithServiceResponseAsync(conversationId, activityId), serviceCallback);
    }

    /**
     * GetActivityMembers.
     * Enumerate the members of an activity.
     This REST API takes a ConversationId and a ActivityId, returning an array of ChannelAccount objects representing the members of the particular activity in the conversation.
     *
     * @param conversationId Conversation ID
     * @param activityId Activity ID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ChannelAccountInner&gt; object
     */
    public Observable<List<ChannelAccountInner>> getActivityMembersAsync(String conversationId, String activityId) {
        return getActivityMembersWithServiceResponseAsync(conversationId, activityId).map(new Func1<ServiceResponse<List<ChannelAccountInner>>, List<ChannelAccountInner>>() {
            @Override
            public List<ChannelAccountInner> call(ServiceResponse<List<ChannelAccountInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * GetActivityMembers.
     * Enumerate the members of an activity.
     This REST API takes a ConversationId and a ActivityId, returning an array of ChannelAccount objects representing the members of the particular activity in the conversation.
     *
     * @param conversationId Conversation ID
     * @param activityId Activity ID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ChannelAccountInner&gt; object
     */
    public Observable<ServiceResponse<List<ChannelAccountInner>>> getActivityMembersWithServiceResponseAsync(String conversationId, String activityId) {
        if (conversationId == null) {
            throw new IllegalArgumentException("Parameter conversationId is required and cannot be null.");
        }
        if (activityId == null) {
            throw new IllegalArgumentException("Parameter activityId is required and cannot be null.");
        }
        return service.getActivityMembers(conversationId, activityId, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ChannelAccountInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ChannelAccountInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ChannelAccountInner>> clientResponse = getActivityMembersDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ChannelAccountInner>> getActivityMembersDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<ChannelAccountInner>, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<ChannelAccountInner>>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

    /**
     * UploadAttachment.
     * Upload an attachment directly into a channel's blob storage.
     This is useful because it allows you to store data in a compliant store when dealing with enterprises.
     The response is a ResourceResponse which contains an AttachmentId which is suitable for using with the attachments API.
     *
     * @param conversationId Conversation ID
     * @param attachmentUpload Attachment data
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorResponseException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ResourceResponseInner object if successful.
     */
    public ResourceResponseInner uploadAttachment(String conversationId, AttachmentDataInner attachmentUpload) {
        return uploadAttachmentWithServiceResponseAsync(conversationId, attachmentUpload).toBlocking().single().body();
    }

    /**
     * UploadAttachment.
     * Upload an attachment directly into a channel's blob storage.
     This is useful because it allows you to store data in a compliant store when dealing with enterprises.
     The response is a ResourceResponse which contains an AttachmentId which is suitable for using with the attachments API.
     *
     * @param conversationId Conversation ID
     * @param attachmentUpload Attachment data
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ResourceResponseInner> uploadAttachmentAsync(String conversationId, AttachmentDataInner attachmentUpload, final ServiceCallback<ResourceResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(uploadAttachmentWithServiceResponseAsync(conversationId, attachmentUpload), serviceCallback);
    }

    /**
     * UploadAttachment.
     * Upload an attachment directly into a channel's blob storage.
     This is useful because it allows you to store data in a compliant store when dealing with enterprises.
     The response is a ResourceResponse which contains an AttachmentId which is suitable for using with the attachments API.
     *
     * @param conversationId Conversation ID
     * @param attachmentUpload Attachment data
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResourceResponseInner object
     */
    public Observable<ResourceResponseInner> uploadAttachmentAsync(String conversationId, AttachmentDataInner attachmentUpload) {
        return uploadAttachmentWithServiceResponseAsync(conversationId, attachmentUpload).map(new Func1<ServiceResponse<ResourceResponseInner>, ResourceResponseInner>() {
            @Override
            public ResourceResponseInner call(ServiceResponse<ResourceResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * UploadAttachment.
     * Upload an attachment directly into a channel's blob storage.
     This is useful because it allows you to store data in a compliant store when dealing with enterprises.
     The response is a ResourceResponse which contains an AttachmentId which is suitable for using with the attachments API.
     *
     * @param conversationId Conversation ID
     * @param attachmentUpload Attachment data
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResourceResponseInner object
     */
    public Observable<ServiceResponse<ResourceResponseInner>> uploadAttachmentWithServiceResponseAsync(String conversationId, AttachmentDataInner attachmentUpload) {
        if (conversationId == null) {
            throw new IllegalArgumentException("Parameter conversationId is required and cannot be null.");
        }
        if (attachmentUpload == null) {
            throw new IllegalArgumentException("Parameter attachmentUpload is required and cannot be null.");
        }
        Validator.validate(attachmentUpload);
        return service.uploadAttachment(conversationId, attachmentUpload, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ResourceResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<ResourceResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ResourceResponseInner> clientResponse = uploadAttachmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ResourceResponseInner> uploadAttachmentDelegate(Response<ResponseBody> response) throws ErrorResponseException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ResourceResponseInner, ErrorResponseException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ResourceResponseInner>() { }.getType())
                .register(201, new TypeToken<ResourceResponseInner>() { }.getType())
                .register(202, new TypeToken<ResourceResponseInner>() { }.getType())
                .registerError(ErrorResponseException.class)
                .build(response);
    }

}
